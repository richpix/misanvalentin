<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jardin de Amor - San Valentin</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Quicksand:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <style>
        :root {
            --bg: #1a0a10;
            --fg: #fff0f3;
            --muted: #d4a5a5;
            --accent: #ff6b8a;
            --accent-warm: #ffb4c2;
            --card: rgba(45, 20, 28, 0.85);
            --border: rgba(255, 107, 138, 0.2);
            --heart: #ff3366;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Quicksand', sans-serif;
            background: var(--bg);
            color: var(--fg);
            overflow: hidden;
            min-height: 100vh;
        }
        
        .title-font { font-family: 'Pacifico', cursive; }
        
        #canvas-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
        }
        
        canvas { display: block; }
        
        .ui-overlay {
            position: fixed;
            z-index: 10;
            pointer-events: none;
        }
        
        .ui-overlay > * { pointer-events: auto; }
        
        .glass-panel {
            background: var(--card);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(255, 51, 102, 0.15);
        }
        
        .heart-icon {
            display: inline-block;
            color: var(--heart);
            animation: heartbeat 1.5s ease-in-out infinite;
        }
        
        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.1); }
            50% { transform: scale(1); }
            75% { transform: scale(1.15); }
        }
        
        .garden-btn {
            position: relative;
            padding: 10px 18px;
            background: transparent;
            border: 2px solid var(--border);
            border-radius: 14px;
            color: var(--fg);
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }
        
        .garden-btn::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, var(--accent), #ff3366);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .garden-btn:hover::before, .garden-btn.active::before { opacity: 1; }
        .garden-btn:hover, .garden-btn.active {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(255, 107, 138, 0.4);
        }
        .garden-btn span { position: relative; z-index: 1; }
        
        .control-btn {
            width: 48px; height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--card);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 14px;
            color: var(--fg);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .control-btn:hover {
            background: rgba(255, 107, 138, 0.25);
            border-color: var(--accent);
            transform: scale(1.05);
        }
        .control-btn.active { background: var(--accent); color: var(--bg); }
        
        .loading-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a0a10 0%, #2d1420 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }
        .loading-screen.hidden { opacity: 0; visibility: hidden; }
        
        .loader-heart {
            font-size: 48px;
            color: var(--heart);
            animation: heartbeat 1s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        
        @media (max-width: 640px) {
            .garden-btn { padding: 8px 12px; font-size: 11px; }
            .control-btn { width: 40px; height: 40px; }
        }
        
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loading">
        <div class="loader-heart mb-4">&#10084;</div>
        <p class="title-font text-2xl text-[var(--accent)]">Preparando el amor...</p>
    </div>
    
    <div id="canvas-container"></div>
    
    <div class="ui-overlay top-0 left-0 right-0 p-4 sm:p-6">
        <div class="glass-panel p-4 sm:p-5 max-w-lg mx-auto text-center">
            <h1 class="title-font text-3xl sm:text-4xl bg-gradient-to-r from-[var(--accent-warm)] via-[var(--heart)] to-[var(--accent)] bg-clip-text text-transparent">
                Lili & Richie
            </h1>
            <p class="text-[var(--muted)] text-sm mt-2 flex items-center justify-center gap-2">
                <span class="heart-icon">&#10084;</span>
                Jardin del Amor
                <span class="heart-icon">&#10084;</span>
            </p>
        </div>
    </div>
    
    <div class="ui-overlay bottom-0 left-0 right-0 p-4 sm:p-6">
        <div class="glass-panel p-4 max-w-md mx-auto">
            <p class="text-[var(--muted)] text-xs uppercase tracking-wider mb-3 text-center">Escenario romantico</p>
            <div class="flex flex-wrap justify-center gap-2 sm:gap-3">
                <button class="garden-btn active" data-garden="sunset"><span>Atardecer</span></button>
                <button class="garden-btn" data-garden="night"><span>Noche Estrellada</span></button>
                <button class="garden-btn" data-garden="spring"><span>Primavera</span></button>
            </div>
        </div>
    </div>
    
    <div class="ui-overlay top-1/2 right-4 sm:right-6 -translate-y-1/2">
        <div class="flex flex-col gap-2">
            <button class="control-btn active" id="btn-rotate" title="Rotacion">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/>
                    <path d="M21 3v5h-5"/>
                </svg>
            </button>
            <button class="control-btn" id="btn-reset" title="Reiniciar">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                    <path d="M3 3v5h5"/>
                </svg>
            </button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        const BLOCK_SIZE = 1;
        const BLOCK_GAP = 0.02;
        const UNIT_SIZE = BLOCK_SIZE + BLOCK_GAP;
        
        const GARDENS = {
            sunset: {
                name: 'Atardecer',
                sky: { top: '#ff6b6b', bottom: '#ffc4a3' },
                ambient: 0xffe4e1, ambientIntensity: 0.5,
                directional: 0xff7f50, directionalIntensity: 1.0,
                ground: '#8fbc8f', groundAccent: '#7cb07c',
                petalColors: ['#ffb4c2', '#ff91a4', '#ffc0cb', '#ff69b4'],
                leafColors: ['#228b22', '#32cd32', '#2e8b57']
            },
            night: {
                name: 'Noche Estrellada',
                sky: { top: '#0d0d2b', bottom: '#1a1a4e' },
                ambient: 0x4a4a8a, ambientIntensity: 0.3,
                directional: 0x9f7aea, directionalIntensity: 0.6,
                ground: '#2d3a2d', groundAccent: '#1f2a1f',
                petalColors: ['#dda0dd', '#da70d6', '#ba55d3', '#9932cc'],
                leafColors: ['#1a3a1a', '#2d5a2d', '#1e4a1e'],
                stars: true
            },
            spring: {
                name: 'Primavera Rosa',
                sky: { top: '#ffc0cb', bottom: '#ffe4e8' },
                ambient: 0xfff0f5, ambientIntensity: 0.6,
                directional: 0xffb6c1, directionalIntensity: 1.0,
                ground: '#90ee90', groundAccent: '#7dda7d',
                petalColors: ['#ff69b4', '#ff1493', '#ff85a2', '#ff6b8a'],
                leafColors: ['#3cb371', '#2e8b57', '#66cdaa']
            }
        };
        
        let scene, camera, renderer, controls;
        let gardenGroup = null;
        let autoRotate = true;
        let currentGarden = 'sunset';
        let floatingHearts = [];
        let nameSprites = [];
        
        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(14, 10, 14);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 35;
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.target.set(0, 3, 0);
            
            setupLights();
            buildGarden(currentGarden);
            
            window.addEventListener('resize', onResize);
            setupUI();
            
            setTimeout(() => { document.getElementById('loading').classList.add('hidden'); }, 1000);
            animate();
        }
        
        function setupLights() {
            scene.add(new THREE.AmbientLight(0xffe4e1, 0.5));
            const dir = new THREE.DirectionalLight(0xff7f50, 1.0);
            dir.position.set(15, 25, 15);
            dir.castShadow = true;
            dir.shadow.mapSize.width = 2048;
            dir.shadow.mapSize.height = 2048;
            dir.shadow.camera.near = 0.5; dir.shadow.camera.far = 60;
            dir.shadow.camera.left = -25; dir.shadow.camera.right = 25;
            dir.shadow.camera.top = 25; dir.shadow.camera.bottom = -25;
            scene.add(dir);
            scene.add(new THREE.HemisphereLight(0xffc0cb, 0x228b22, 0.4));
        }
        
        function createBlock(x, y, z, color, castShadow = true) {
            const geo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.6, metalness: 0.1 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x * UNIT_SIZE, y * UNIT_SIZE, z * UNIT_SIZE);
            mesh.castShadow = castShadow;
            mesh.receiveShadow = true;
            return mesh;
        }
        
        function createGround(config) {
            const group = new THREE.Group();
            for (let x = -10; x <= 10; x++) {
                for (let z = -10; z <= 10; z++) {
                    const color = (x + z) % 4 === 0 ? config.groundAccent : config.ground;
                    group.add(createBlock(x, 0, z, color, false));
                }
            }
            return group;
        }
        
        function createTreeOfLove(config) {
            const group = new THREE.Group();
            const trunk = '#8b4513';
            for (let y = 1; y <= 6; y++) {
                group.add(createBlock(0, y, 0, trunk));
                if (y <= 3) { group.add(createBlock(1, y, 0, trunk)); group.add(createBlock(-1, y, 0, trunk)); }
            }
            
            const heartPattern = [
                { y: 7, b: [[0,0]] },
                { y: 8, b: [[-1,0],[0,0],[1,0]] },
                { y: 9, b: [[-2,0],[-1,0],[0,0],[1,0],[2,0],[-1,1],[0,1],[1,1]] },
                { y: 10, b: [[-3,0],[-2,0],[-1,0],[0,0],[1,0],[2,0],[3,0],[-2,1],[-1,1],[0,1],[1,1],[2,1]] },
                { y: 11, b: [[-3,0],[-2,0],[-1,0],[0,0],[1,0],[2,0],[3,0],[-3,1],[-2,1],[-1,1],[0,1],[1,1],[2,1],[3,1],[-2,-1],[-1,-1],[0,-1],[1,-1],[2,-1]] },
                { y: 12, b: [[-2,0],[-1,0],[0,0],[1,0],[2,0],[-2,1],[-1,1],[0,1],[1,1],[2,1],[-1,-1],[0,-1],[1,-1]] },
                { y: 13, b: [[-1,0],[0,0],[1,0],[-1,1],[0,1],[1,1]] },
                { y: 14, b: [[0,0]] }
            ];
            
            heartPattern.forEach(l => {
                l.b.forEach(([dx, dz]) => {
                    const blk = createBlock(dx, l.y, dz, config.leafColors[Math.floor(Math.random() * config.leafColors.length)]);
                    blk.scale.set(0.95, 0.95, 0.95);
                    group.add(blk);
                });
            });
            return group;
        }
        
        function createHeart(x, y, z, scale = 1) {
            const group = new THREE.Group();
            const heartBlocks = [
                [0,0], [1,0], [-1,0], [2,0], [-2,0],
                [0,1], [1,1], [-1,1], [2,1], [-2,1],
                [0,2], [1,2], [-1,2], [0,3]
            ];
            heartBlocks.forEach(([dx, dy]) => {
                const b = createBlock(dx * 0.3, dy * 0.3, 0, '#ff3366');
                b.scale.set(0.3, 0.3, 0.3);
                group.add(b);
            });
            group.position.set(x * UNIT_SIZE, y * UNIT_SIZE, z * UNIT_SIZE);
            group.scale.setScalar(scale);
            return group;
        }
        
        function createPerson(x, z, isFemale, name) {
            const group = new THREE.Group();
            const skin = '#ffd5b5';
            const hair = isFemale ? '#6a3820' : '#2c1810';
            const shirt = isFemale ? '#ff69b4' : '#4169e1';
            const pants = isFemale ? '#ffb4c2' : '#2c3e50';
            
            let y = 1;
            
            // Pies y piernas
            group.add(createBlock(x - 0.3, y, z, pants));
            group.add(createBlock(x + 0.3, y, z, pants)); y++;
            group.add(createBlock(x - 0.3, y, z, pants));
            group.add(createBlock(x + 0.3, y, z, pants)); y++;
            
            // Torso
            for (let i = 0; i < 2; i++) {
                const t = createBlock(x, y, z, shirt);
                t.scale.set(1.3, 1, 1);
                group.add(t); y++;
            }
            
            // Brazos abiertos
            const arm = createBlock(x + (isFemale ? -1.2 : 1.2), y - 1, z, shirt);
            arm.scale.set(0.4, 1.5, 0.8);
            group.add(arm);
            
            // Cabeza
            const head = createBlock(x, y, z, skin);
            head.scale.set(1.2, 1.2, 1.2);
            group.add(head);
            
            // --- PEINADOS (Corregidos para ver los ojos) ---
            
            if (isFemale) {
                // CABELLO LILI
                
                // 1. Cabello encima de la cabeza
                const topHair = createBlock(x, y + 0.8, z, hair);
                topHair.scale.set(1.2, 0.35, 1.1);
                group.add(topHair);
                
                // 2. Flequillo (CORREGIDO: mas arriba y mas estrecho)
                // Lo subimos a y+0.35 para que no tape los ojos (que estan en y)
                const bangs = createBlock(x, y + 0.35, z + 0.6, hair);
                bangs.scale.set(0.8, 0.3, 0.35); // Ancho reducido a 0.8
                group.add(bangs);
                
                // 3. Cabello largo atras
                for (let i = 0; i < 3; i++) {
                    const longHair = createBlock(x, y - (i * 0.6), z - 0.55, hair);
                    longHair.scale.set(1.1, 0.6, 0.4);
                    group.add(longHair);
                }
                
                // 4. Laterales
                const sideL = createBlock(x - 0.65, y, z + 0.1, hair);
                sideL.scale.set(0.25, 0.7, 0.8);
                group.add(sideL);
                
                const sideR = createBlock(x + 0.65, y, z + 0.1, hair);
                sideR.scale.set(0.25, 0.7, 0.8);
                group.add(sideR);
                
            } else {
                // CABELLO RICHIE
                
                const topHair = createBlock(x, y + 0.75, z, hair);
                topHair.scale.set(1.1, 0.3, 1.1);
                group.add(topHair);
                
                const frontHair = createBlock(x, y + 0.4, z + 0.55, hair);
                frontHair.scale.set(0.9, 0.3, 0.3);
                group.add(frontHair);
            }
            
            // OJOS (Corregidos: ligeramente mas adelante para asegurar visibilidad)
            const eyeColor = '#2c1810';
            const eyeY = y; 
            const eyeZ = z + 0.65; // Un poco mas adelante
            
            const lEye = createBlock(x - 0.3, eyeY, eyeZ, eyeColor);
            lEye.scale.set(0.2, 0.2, 0.1);
            group.add(lEye);
            
            const rEye = createBlock(x + 0.3, eyeY, eyeZ, eyeColor);
            rEye.scale.set(0.2, 0.2, 0.1);
            group.add(rEye);
            
            // Cartel de nombre
            group.add(createNameLabel(name, x, y + 2.5, z));
            
            return group;
        }
        
        function createNameLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 128;
            
            ctx.fillStyle = 'rgba(255, 51, 102, 0.9)';
            ctx.beginPath(); ctx.roundRect(20, 30, 216, 68, 16); ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.roundRect(20, 30, 216, 68, 16); ctx.stroke();
            
            ctx.font = 'bold 42px Quicksand, sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 128, 64);
            
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
            const sprite = new THREE.Sprite(mat);
            sprite.position.set(x * UNIT_SIZE, y * UNIT_SIZE, z * UNIT_SIZE);
            sprite.scale.set(2.5, 1.25, 1);
            nameSprites.push(sprite);
            return sprite;
        }
        
        function createCouple() {
            const group = new THREE.Group();
            
            const lili = createPerson(-0.7, 0, true, 'Lili');
            lili.rotation.y = Math.PI * 0.15; 
            group.add(lili);
            
            const richie = createPerson(0.7, 0, false, 'Richie');
            richie.rotation.y = -Math.PI * 0.15; 
            group.add(richie);
            
            const heart = createHeart(0, 7.5, 0, 0.8);
            heart.userData.isFloatingHeart = true;
            floatingHearts.push(heart);
            group.add(heart);
            
            group.position.set(0, 0, 2);
            return group;
        }
        
        function createFlowerPatch(x, z, config) {
            const group = new THREE.Group();
            for (let i = 0; i < 5; i++) {
                const fx = x + (Math.random() - 0.5) * 2;
                const fz = z + (Math.random() - 0.5) * 2;
                const stem = createBlock(fx, 1, fz, '#228b22');
                stem.scale.set(0.3, 0.6, 0.3); group.add(stem);
                const petal = createBlock(fx, 1.5, fz, config.petalColors[Math.floor(Math.random() * config.petalColors.length)]);
                petal.scale.set(0.5, 0.3, 0.5); group.add(petal);
            }
            return group;
        }
        
        function createBench(x, z) {
            const group = new THREE.Group();
            const w = '#8b4513';
            group.add(createBlock(x - 1, 1, z - 0.5, w)); group.add(createBlock(x + 1, 1, z - 0.5, w));
            group.add(createBlock(x - 1, 1, z + 0.5, w)); group.add(createBlock(x + 1, 1, z + 0.5, w));
            for (let dx = -1.5; dx <= 1.5; dx++) {
                const s = createBlock(x + dx, 2, z, w);
                s.scale.set(1, 0.3, 1.5); group.add(s);
            }
            return group;
        }
        
        function createStars() {
            const group = new THREE.Group();
            for (let i = 0; i < 80; i++) {
                const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 + Math.random() * 0.4 });
                const star = new THREE.Mesh(geo, mat);
                const th = Math.random() * Math.PI * 2;
                const ph = Math.random() * Math.PI * 0.4;
                const r = 40 + Math.random() * 20;
                star.position.set(r * Math.sin(ph) * Math.cos(th), r * Math.cos(ph) + 10, r * Math.sin(ph) * Math.sin(th));
                star.userData.twinkleSpeed = 1 + Math.random() * 2;
                star.userData.twinkleOffset = Math.random() * Math.PI * 2;
                group.add(star);
            }
            return group;
        }
        
        function buildGarden(type) {
            const c = GARDENS[type];
            if (gardenGroup) {
                scene.remove(gardenGroup);
                gardenGroup.traverse(ch => {
                    if (ch.geometry) ch.geometry.dispose();
                    if (ch.material) { if (ch.material.map) ch.material.map.dispose(); ch.material.dispose(); }
                });
            }
            floatingHearts = []; nameSprites = [];
            gardenGroup = new THREE.Group();
            
            scene.background = new THREE.Color(c.sky.top);
            
            gardenGroup.add(createGround(c));
            gardenGroup.add(createTreeOfLove(c));
            gardenGroup.add(createCouple());
            
            [[-5,-5],[5,-5],[-5,5],[5,5],[-7,0],[7,0],[0,-7],[0,7],[-4,4],[4,-4]].forEach(p => gardenGroup.add(createFlowerPatch(p[0],p[1],c)));
            gardenGroup.add(createBench(-6, -3)); gardenGroup.add(createBench(6, -3));
            
            [[-3,1,-3],[3,1,-3],[-3,1,5],[3,1,5]].forEach(p => {
                const h = createHeart(p[0], p[1], p[2], 0.4);
                h.userData.isFloatingHeart = true; floatingHearts.push(h); gardenGroup.add(h);
            });
            
            if (c.stars) gardenGroup.add(createStars());
            scene.add(gardenGroup);
        }
        
        function setupUI() {
            document.querySelectorAll('.garden-btn').forEach(b => b.addEventListener('click', () => {
                document.querySelectorAll('.garden-btn').forEach(x => x.classList.remove('active'));
                b.classList.add('active');
                buildGarden(b.dataset.garden);
            }));
            document.getElementById('btn-rotate').addEventListener('click', function() { autoRotate = !autoRotate; this.classList.toggle('active'); });
            document.getElementById('btn-reset').addEventListener('click', () => {
                camera.position.set(14, 10, 14); controls.target.set(0, 3, 0); controls.update();
            });
        }
        
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const t = Date.now() * 0.001;
            if (autoRotate && gardenGroup) gardenGroup.rotation.y += 0.002;
            floatingHearts.forEach((h, i) => {
                if (h.userData.isFloatingHeart) {
                    h.position.y += Math.sin(t * 2 + i) * 0.003;
                    h.rotation.y += 0.01;
                }
            });
            nameSprites.forEach(s => s.lookAt(camera.position));
            if (gardenGroup) gardenGroup.traverse(ch => {
                if (ch.userData.twinkleSpeed) ch.material.opacity = 0.4 + Math.sin(t * ch.userData.twinkleSpeed + ch.userData.twinkleOffset) * 0.4;
            });
            controls.update();
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>